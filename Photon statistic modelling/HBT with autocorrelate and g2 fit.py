##############################################################################
# Import some libraries
##############################################################################
import sys
import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

##############################################################################
# Import some extra special libraries from my own repo and do some other stuff
##############################################################################
sys.path.insert(0, r"C:\local files\Python\Local Repo\library")
import prd_data_proc
import prd_plots
import prd_maths
np.set_printoptions(suppress=True)
cs = prd_plots.palette()

##############################################################################
# Import generated data
##############################################################################
# load photon timing files generated by 'Generate photons.py'
T = 5
γs = 1e6
p0 = r'C:\local files\Experimental Data\G5 A5 Python simulations'\
    r'\Single photon statistics\Data\20191211'

f0 = p0 + r'\1e' + str(int(np.log10(γs))) + ' Photons, ' + \
    'T = ' + str(int(T * 100)) + ' ts abs.txt'
f1 = p0 + r'\1e' + str(int(np.log10(γs))) + ' Photons, ' + \
    'T = ' + str(int(T * 100)) + ' ts rel.txt'
f2 = p0 + r'\1e' + str(int(np.log10(γs))) + ' Photons, ' + \
    'T = ' + str(int(T * 100)) + ' ts 1.txt'
f3 = p0 + r'\1e' + str(int(np.log10(γs))) + ' Photons, ' + \
    'T = ' + str(int(T * 100)) + ' ts 2.txt'
f4 = p0 + r'\1e' + str(int(np.log10(γs))) + ' Photons, ' + \
    'T = ' + str(int(T * 100)) + ' ts HBT.txt'
f5 = p0 + r'\1e' + str(int(np.log10(γs))) + ' Photons, ' + \
    'T = ' + str(int(T * 100)) + ' fom.txt'

ts_abs = np.loadtxt(f0)
ts_rel = np.loadtxt(f1)
ts_1 = np.loadtxt(f2)
ts_2 = np.loadtxt(f3)
print(len(ts_2))
ts_HBT = np.loadtxt(f4)
print(len(ts_HBT))
fom = np.loadtxt(f5)
t = fom[0]
Δt = fom[1]
γs = fom[2]
t_max = np.max(ts_abs)
print(np.shape(ts_abs))
γ_rate = γs / t_max
print('total time = ', np.round(t_max / 1e9, 2), 's')
print('total photons = ', np.round(γs))
print('total count rate = ', np.round(γ_rate * 1e6, 3), ' kcps')

n = min(len(ts_1), len(ts_2))
ts_1c = ts_1[0:n]
ts_2c = ts_2[0:n]

#######################################################################
# Do alternative 'beam splitting' by randomly allocating
# τs_abs elements to alt_t1 & alt_t2
#######################################################################

alt_t1 = []
alt_t2 = []
for i0, v0 in enumerate(ts_abs):
    if np.random.random() < 0.5:
        alt_t1.append(v0)
    else:
        alt_t2.append(v0)

print(len(alt_t1), len(alt_t2))
n = min(len(alt_t1), len(alt_t2))
alt_t1 = alt_t1[0:n]
alt_t2 = alt_t2[0:n]

#######################################################################
# Generate time series based on photon arrival times
#######################################################################

ts1 = np.zeros(int(np.max(ts_1c)))
ts2 = np.zeros(int(np.max(ts_2c)))
# print(np.shape(ts1))
# print(np.shape(ts2))
for i0, v0 in enumerate(ts_1c):
    ts1[int(v0) - 1] = 1

for i0, v0 in enumerate(ts_2c):
    ts2[int(v0) - 1] = 1

print(np.shape(ts1))

# alt_τ = np.linspace(-1000, 1000, 2001)
# t1_bar = len(alt_t1) / np.max(alt_t1)
# t2_bar = len(alt_t2) / np.max(alt_t2)
# g2 = []
# for i0, v0 in alt_τ:
#     g2.append()
n1 = 100000
g = np.correlate(ts1[0:n1], ts2[0:n1], 'full')


#######################################################################
# Analytic approach to correlation measurements
#######################################################################
# see prd_maths.g2_3_lvl functions
a = 0.1
b = 0.002
c = 1
d = 0.0005
τs = np.linspace(-1500, 1500, 5000)
init = [a, b, c, d]
# g2 function taken from "Berthel et al 2015"
fit = 1 - c * np.exp(- a * np.abs(τs)) \
    + (c - 1) * np.exp(- b * np.abs(τs))
exp_decay = (np.exp(- d * np.abs(τs)))
fit_total = fit * exp_decay

#######################################################################
# Plot some figures
#######################################################################
prd_plots.ggplot()
print('HBT ', len(ts_HBT))
print('diff ', len(ts_1c))
# histograms
x1 = ts_HBT

x1 = [i for i in x1 if i <= 1200]
x1 = [i for i in x1 if i >= -1200]

# x2 = np.asarray(alt_t1, dtype=np.int) - np.asarray(alt_t2, dtype=np.int)
x2 = ts_1c - ts_2c
x2 = [i for i in x2 if i <= 1200]
x2 = [i for i in x2 if i >= -1200]
print(np.shape(x1)[0])
print(np.shape(x2)[0])

bin_N = 501
hist1, bins1 = np.histogram(x1, bins=bin_N, density=False)
hist2, bins2 = np.histogram(x2, bins=bin_N, density=False)

bin_centres1 = np.linspace(bins1[0] + (bins1[1] - bins1[0]) / 2,
                           bins1[-2] + (bins1[-1] - bins1[-2]) / 2,
                           len(bins1) - 1)
hist_time1 = np.linspace(bins1[0] + (bins1[1] - bins1[0]) / 2,
                         bins1[-2] + (bins1[-1] - bins1[-2]) / 2, 1000)

bin_width1 = bins1[1] - bins1[0]

bin_centres2 = np.linspace(bins2[0] + (bins2[1] - bins2[0]) / 2,
                           bins2[-2] + (bins2[-1] - bins2[-2]) / 2,
                           len(bins1) - 1)
hist_time2 = np.linspace(bins2[0] + (bins2[1] - bins2[0]) / 2,
                         bins2[-2] + (bins2[-1] - bins2[-2]) / 2, 1000)

bin_width2 = bins2[1] - bins2[0]

# This normalisation is dicey. Normally you'd do:
# (hist * t_max) / (γs_ch1 * γs_ch2 * bin_width) for an HBT.
g2s_exp1 = (hist1 * t_max) / (len(ts_HBT) * len(ts_HBT) * bin_width1)
g2s_exp2 = (hist2 * t_max) / (len(ts_1) * len(ts_2) * bin_width2)

# funciton histogram seems to divide by 100 somewhere
y1 = g2s_exp1
y2 = g2s_exp2

popt, pcov = curve_fit(prd_maths.g2_3_lvl_exp,
                       bin_centres1, y1, p0=[*init])

# fig1 = plt.figure('fig1', figsize=(3 * np.sqrt(2), 3))
# ax1 = fig1.add_subplot(1, 1, 1)
# fig1.patch.set_facecolor(cs['mnk_dgrey'])
# ax1.set_xlabel('')
# ax1.set_ylabel('')
plt.plot(g, '.')
# plt.tight_layout()
# plt.show()

fig2 = plt.figure('fig2', figsize=(3 * np.sqrt(2), 3))
ax2 = fig2.add_subplot(1, 1, 1)
fig2.patch.set_facecolor(cs['mnk_dgrey'])
ax2.set_xlabel('Time')
ax2.set_ylabel('#')
# ax2.set_yscale('log')
ax2.plot(bin_centres1, y1, '.', color=cs['ggblue'])
ax2.plot(bin_centres2, y2, '.', color=cs['ggpurple'])
# plt.hist(x2, bins=bin_N, alpha=0.5,
#          facecolor=cs['ggred'], edgecolor=cs['mnk_dgrey'],
#          label='Probabilistic')
# ax2.plot(τs, fit, '.', label='Analytic')
# ax2.plot(τs, exp_decay, '.', label='Analytic')
ax2.plot(τs, prd_maths.g2_3_lvl_exp(
    τs, *popt), '-',
    color=cs['ggred'],
    label='Fit',
    lw=0.5)
ax2.plot(τs, prd_maths.g2_3_lvl_exp(
    τs, *init), '-',
    color=cs['ggyellow'],
    label='Initial fit',
    lw=0.5)
# ax2.plot(bin_centres, x2, '.', color=cs['ggblue'])
ax2.legend(loc='upper right', fancybox=True, framealpha=0.5)
os.chdir(p0)
plt.savefig('plot.png')
plt.title('τs_HBT')
plt.tight_layout()
# plt.xlim(0, 1000)
plt.show()
